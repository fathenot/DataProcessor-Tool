using System.Runtime.CompilerServices;

// this code is generated by the DataProcessor project using the help of generative tools.
namespace DataProcessor.source.IndexTypes
{
    internal static class IndexUtils
    {
        /// <summary>
        /// help methods to detect and handle multiindex
        /// </summary>
        /// <param name="item"></param>
        /// <returns></returns>
        public static bool IsGroupedIndexElement(object? item)
        {
            return item is object[] ||
                   item is List<object> ||
                   item is ITuple || // covers both Tuple<> and ValueTuple<>
                   item?.GetType().FullName?.StartsWith("System.ValueTuple") == true;
        }

        /// <summary>
        /// Determines whether the specified collection contains at least one grouped index element.
        /// </summary>
        /// <param name="index">The collection of objects to search. Can contain null values.</param>
        /// <returns><see langword="true"/> if the collection contains at least one grouped index element; otherwise, <see
        /// langword="false"/>.</returns>
        public static bool ContainsGroupedIndex(IEnumerable<object?> index)
        {
            if (index == null) return false;
            foreach (var item in index)
            {
                if (IsGroupedIndexElement(item))
                    return true;
            }
            return false;
        }

        /// <summary>
        /// Flattens the specified item into a sequence of individual elements.
        /// </summary>
        /// <remarks>This method supports flattening arrays, lists of objects, and tuples. For other
        /// types, the input is treated as a single element. Null values are not supported and will result in an empty
        /// sequence.</remarks>
        /// <param name="item">The item to flatten. This can be an array, a <see cref="List{T}"/> of objects, an <see cref="ITuple"/>, or
        /// any other object.</param>
        /// <returns>An <see cref="IEnumerable{T}"/> containing the individual elements of the input item. If the input is not a
        /// collection or tuple, the item itself is returned as a single element.</returns>
        public static IEnumerable<object> FlattenIndexElement(object? item)
        {
            if (item == null) yield return item;
            if (item is object[] arr)
            {
                foreach (var el in arr) yield return el;
                yield break;
            }


            if (item is List<object> list)
            {
                foreach (var el in list) yield return el;
                yield break;
            }

            if (item is ITuple tuple)
            {
                for (int i = 0; i < tuple.Length; i++)
                    yield return tuple[i];
                yield break;
            }

            yield return item!;
        }


        public static bool TryFlattenIndex(object indexItem, out object[] flattened)
        {
            if (indexItem is ITuple tuple)
            {
                flattened = new object[tuple.Length];
                for (int i = 0; i < tuple.Length; i++)
                {
                    flattened[i] = tuple[i];
                }
                return true;
            }

            if(indexItem is IEnumerable<object> enumerable)
            {
                flattened = enumerable.ToArray();
                return true;
            }
            flattened = null;
            return false;
        }
        /// <summary>
        /// Determines whether two objects are equal, with special handling for grouped index elements.
        /// </summary>
        /// <remarks>This method provides custom equality logic for objects that represent grouped index
        /// elements. If both <paramref name="a"/> and <paramref name="b"/> are grouped index elements, their flattened
        /// representations are compared element by element. For all other cases, the method falls back to using the
        /// default <see cref="object.Equals(object?)"/> implementation.</remarks>
        /// <param name="a">The first object to compare. Can be a grouped index element or a regular object.</param>
        /// <param name="b">The second object to compare. Can be a grouped index element or a regular object.</param>
        /// <returns><see langword="true"/> if the objects are considered equal; otherwise, <see langword="false"/>. For grouped
        /// index elements, equality is determined by comparing their flattened representations.</returns>
        public static bool IndexEquals(object? a, object? b)
        {
            if (IsGroupedIndexElement(a) && IsGroupedIndexElement(b))
            {
                var aList = new List<object>(FlattenIndexElement(a));
                var bList = new List<object>(FlattenIndexElement(b));

                if (aList.Count != bList.Count)
                    return false;

                for (int i = 0; i < aList.Count; i++)
                {
                    if (!Equals(aList[i], bList[i]))
                        return false;
                }

                return true;
            }

            return Equals(a, b);
        }

        /// <summary>
        /// Provides an equality comparer for objects, with special handling for grouped index elements.
        /// </summary>
        /// <remarks>This comparer uses custom logic to determine equality and compute hash codes for objects
        /// that represent grouped index elements. For grouped index elements, the equality comparison and hash code
        /// generation are based on the flattened structure of the index. For other objects, the default equality and hash
        /// code behavior is used.</remarks>
        public class GroupedIndexEqualityComparer : IEqualityComparer<object?>
        {
            /// <summary>
            /// Determines whether the specified objects are equal.
            /// </summary>
            /// <remarks>This method uses a custom equality comparison logic defined by <see
            /// cref="IndexUtils.IndexEquals"/>.</remarks>
            /// <param name="x">The first object to compare. Can be <see langword="null"/>.</param>
            /// <param name="y">The second object to compare. Can be <see langword="null"/>.</param>
            /// <returns><see langword="true"/> if the specified objects are considered equal; otherwise, <see
            /// langword="false"/>.</returns>
            public new bool Equals(object? x, object? y)
            {
                return IndexUtils.IndexEquals(x, y);
            }

            /// <summary>
            /// Computes a hash code for the specified object.
            /// </summary>
            /// <remarks>This method provides a custom hash code computation for grouped index
            /// elements by flattening them and combining the hash codes of their individual elements. For other
            /// objects, it delegates to the object's own <see cref="object.GetHashCode"/> implementation.</remarks>
            /// <param name="obj">The object for which to compute the hash code. Can be <see langword="null"/>.</param>
            /// <returns>A hash code for the specified object. Returns 0 if <paramref name="obj"/> is <see langword="null"/>. If
            /// the object is a grouped index element, the hash code is computed based on its flattened elements.
            /// Otherwise, the hash code of the object itself is returned.</returns>
            public int GetHashCode(object? obj)
            {
                if (obj == null) return 0;

                if (IndexUtils.IsGroupedIndexElement(obj))
                {
                    unchecked
                    {
                        int hash = 17;
                        foreach (var element in IndexUtils.FlattenIndexElement(obj))
                        {
                            hash = hash * 23 + (element?.GetHashCode() ?? 0);
                        }
                        return hash;
                    }
                }

                return obj.GetHashCode();
            }
        }

    }
}
